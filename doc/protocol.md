Chat: Протокол
=====================================

Протокол основан на собственном шаблоне сетевых протоколов и форматов данных *Paket*. Paket был создан для потоковых данных. Он делит данные на порции (пакеты) или **pakets**. Paket передаёт только данные и их размер, он не передаёт информацию о схеме данных или о том, как их декодировать.

*Я знаю, что правильно packet, можете не сообщать мне*

Формат paket
-------------------------------------

### Заголовок

Каждый пакет имеет заголовок, состоящий из длины (**size**) пакета и идентификационного номера (**id**) пакета (в будущем **branch-id**).

И **id**, и **size** кодируются форматом `uzint` (`uzint` то же самое, что [VarInt] в protobuff). Этот формат имеет различную длину поля для различных данных и используется для кодирования целого числа.

Данные **size** включают в себя длину тела **paket** и длину поля **id**.

### Тело

Сейчас максимальная длина **paket** ограничена 2^(32-1) байтами. Соответственно суммарная длина полей в теле не может привысить это значение. В программе чата это ограничение ужесточено. Дело в том, что **paket** в данной C++ реализации читается в один присест из одного массива. Выделять сверх большие массивы в памяти страшно.

Тело состоит из различного набора полей. Здесь будут описаны те, которые были использованы в протоколе чата.

#### Поле String (текст)

Это поле состоит из длины строки в байтах и самой строки, закодированной в utf-8. Длина кодируется форматом `uzint`.

#### Поле int64 (целое число)

Это поле содержит целое big-endian число разрядностью 64 бита.

### Поле `uzint`

Описание того, как оно кодируется здесь [VarInt]. Назвал я его так, потому что в **paket** может так-же присутствовать поле `szint`, которое оптимально кодирует как положительные, так и отрицательные значения.

Описание протокола чата
-------------------------------------

Протокол работает поверх транспортного протокола с установлением подключения и гарантией доставки сообщений. В текущей реализации это могут быть протоколы TCP или Unix `STREAM_SOCK`.

Любой протокол на основе *Paket* включая текущий состоит из объектов, которые также называются **paket**. Они орписывают набор полей и код **id**. В протоколе чата немного объектов. Их описание на ЯП C++ представлено в файле [protocol.hpp](../src/protocol.hpp).

### Поля объектов **paket**

Далее для каждого типа **paket** объекта будут кратко описаны поля и их формат.

#### handshake (id #0)

| имя      | формат | описание             |
|----------|--------|----------------------|
| version  | uzint  | код версии протокола |
| address  | string | адрес подключения    |
| username | string | имя пользователя     |

#### noop (id #1)

(нет полей)

#### tell (id #2)

| имя      | формат | описание                         |
|----------|--------|----------------------------------|
| message  | string | сообщение, отправленное клиентом |

#### chat (id #3)

| имя      | формат | описание                                     |
|----------|--------|----------------------------------------------|
| time     | int64  | время в секундах начиная с *epoch*           |
| username | string | имя пользователя, который отправил сообщение |
| message  | string | сообщения от этого пользователя              |

### Порядок передачи объектов **paket**

### Инициализация

После подключения клиент должен передать *handshake* с правильным кодом версии `version` (1 в текущей реализации). В поле `address` должен присутствовать тот адрес, по которому клиент обращался чтобы установить подключение (хост или имя файла). В поле `username` должно быть имя, которое будет использоваться в чате от имени этого клиента.

Сервер всегда в праве без объяснения причин разорвать соединение. После получения *handshake* он проверяет код версии, если он не равен 1, то подключение разрывается. Поле адреса `address` сервером никак не используется. Значение поля `username` сохраняется в данных сессии клиента.

### Передача сообщений

Клиент после установления подключения может отправить *tell*. В поле `message` при этом указывается сообщение, которое отправляет клиент.

Сервер принимает этот объект и отсылает один и тот же объект *chat* всем клиентам, включая того, что отправил сообщение. В поле `time` при этом записывается текущее время, в `username` имя отправителя, а в `message` копируются данные из объекта *tell* поля `message`.

### Keep Alive

Сервер каждый раз, когда принимает какие-либо данные от клиента, сбрасывает обратный отсчёт до разрыва соединения с клиентом. Чтобы подключение не было разорвано по этой причине, клиенту следует переодически отправлять объект *noop*. Для объекта *noop* сервер не выполняет никакой работы, но обратный отсчёт до разрыва соединения при этом сбрасывается.

Такое поведение было создано в целях обнаружения потери связи с одним из клиентов. Чат может прослушиваться клиентами и при этом ни один из клиентов не будет слать сообщение. В таком состоянии данные передоваться не будут, но один из клиентов может успеть отключиться из-за потери связи. Сервер об этом не узнает и продолжит занимать его имя пользователя и другие ресурсы. Сервер можно запустить с настройками, которые обеспечивает уникальность имён пользователей и ограничение на количество. Такие настройки могут сделать чат недоступным. Чтобы этого избежать пользователи чата и администратор сервера должны договориться о минимальной переодичности сообщений, которые должны поступать от клиента.

В данной реализации чата на сервере переодичность сообщений указывается опцией **--timeout**, а на клиенте **--pulse**.

### Отключение

И клиент и сервер могут разорвать подключение. После разрыва соединения с клиентом, сервер удаляет данные сессии этого клиента. Клиент в этом случае завершает работу.

[VarInt]: https://developers.google.com/protocol-buffers/docs/encoding#varints
